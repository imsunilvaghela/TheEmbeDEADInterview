1. When Volatile is needed ?
2. What is an advantage of having .bss section ?
3. Function pointer and example, use-cases
4. Double pointers
5. Memory allocation / free
  5.1. Return value of malloc(0)  (A: NULL)
  5.2. Have you fixed any memory leakage issues ? Which tools are available to check memory leakage ?
  5.3. Use of Valgrind to check memory leakage
6. Structure and Union
  6.1. What is practical Use of structure and Union?
7. Data types in C
  7.1. Does integer size varies per platform or remains constant ? Is it dependent on compiler as well ?
       What could be the size of integer when I use 32 bit compiler in 64 bit OS ?
  7.2. When I say 64 bit OS – what does that 64 represents ?
  7.3. Is it possible to use 32 bit OS with more than 4GB of RAM ? NO: Why is it not possible?
8. Pointers
  8.1. What is a void pointer? Can you dereference a void pointer without knowing its type?
  >A>
  A void pointer is a pointer that can be used to point to any data of any arbitrary type. A void pointer
  can be dereferenced only after explicit casting.    e.g.:
      int a = 5;
      void *b = &a;
      printf(“%d\n”, *((int*)b));
9. Difference between following declarations:
   - const int *p / int const *p;
   - int *const p;
   - const int* const p;
10. What is stack overflow ? Why does it happens and how to avoid it ? / If recursive function
    can't return then what happens ?
11. Can a C program be compiled or executed in the absence of a main()?
12. Storage classes
  12.1. Can we use register variable as Global ?
  12.2. Can we use pointer on register variable? Why ?
13. Can a variable be volatile & const? In which scenario this will happen?
  >A> Yes, When we want to read external GPIO memory.
14. Can we define macro inside structure definition?
15. Difference between static function, static inline function & macro.
16. How 32 bit system differs from 64 bit system. What about the address space. Does pointer
    size differs? What we need to take care to obtain portability? What code would you write
    for it to be non-functional on 64 bit system.
17. How does free() call frees memory even when we don't provide number of bytes to free it ?


Programs:
---------
01. Implement custom malloc() function – pseudo code and approach understanding
02. Decimal to Hexadecimal / Float to Binary
03. Write custom macro for sizeof
04. Implement itoa function. Integer to ascii conversion.
05. Implement strcspn().  Given 2 strings, strcspn() calculates the length of the
    number of characters before the 1st occurrence of the character present in both
    the string. Return -1, if no match found.
    e.g. str1="theembedeadinterview", str2="test" -> 0
        str1="theembedeadinterview", str2="west" -> 2
        str1="theembedeadinterview", str2="fly" -> -1
06. #define GENMASK(high, low)
    e.g. GENMASK(7,0) ->  11111111 i.e. 255
        GENMASK(1,0) ->  00000011 i.e. 3
        GENMASK(5,3) ->  00111000 i.e. 56
        GENMASK(15,11) ->  11111000 00000000 i.e. 63488
07. Given a string, Return a char which has occured a maximum times. If found two
    or more characters, return last occurance of the last one found. If found only
    one occurance of a character, then return the last char found.
    e.g. str="program" -> r
        str="programming" -> g
        str="print" -> t
08. Given a string of paranthesis, return if it is balanced or not.
    e.g. str="[()]{<>}{[()()]()}" -> Balanced
        str="[(])" -> Not Balanced
09. Given a string s, find the length of longest substring without repeating characters.
    e.g. str="theembedeadinterview" -> 8 (adinterv)
12. Implement a stack using array. Push, Pop and peek operations
13. Search the Nth node to the end of a singly-linked-list? Two-pass? Or Single-pass?
14. Design an algorithm and write code to remove the duplicate characters in a string
    without using any additional buffer.
    NOTE: One or two additional variables are fine. An extra copy of the array is not.
15. You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a
    method to set all bits between i and j in N equal to M (e.g., M becomes a substring of
    N located at i and starting at j).
    e.g.
    Input: N = 10000000000, M = 10101, i = 2, j = 6
    Output: N = 10001010100
16. Given an integer, print the next smallest and next largest number that have the same
    number of 1 bits in their binary representation.
17. Write a function to determine the number of bits required to convert integer A to integer B.
    e.g.
    Input: 31, 14
    Output: 2
18. Write a program to figure out if someone has won in a game of tic-tac-toe.
    Input will be char array of 9 bytes. e.g. "xoxxxooxo", "xoxxxooox"

Patterns
--------
01. Print below pattern for the given string. if the string is of even
    characters add x in the middle.
    e.g. str="program"
       p     m
        r   a
         o r
          g
         r o
        a   r
       m     p

    e.g. str="colour"
       c     r
        o   u
         l o
          x
         o l
        u   o
       r     c
02.
           A
          B C
         D E F
        G H I J
       K L M N O
        P Q R S
         T U V
          W X
           Y
03. n > 0 && n % 2 == 1 
    n = 7
       * * * * * * *
       * * *   * * *
       * *       * *
       *           *
       * *       * *
       * * *   * * *
       * * * * * * *
04.
               1
             2 3 2
           3 4 5 4 3
         4 5 6 7 6 5 4
       5 6 7 8 9 8 7 6 5

05. n > 0 && n % 2 == 1
    n = 4
       *           *
       * *       * *
       * * *   * * *
       * * * * * * *
       * * *   * * *
       * *       * *
       *           *
06. n >=6 && n % 2 == 0
       n = 10
       **********
       **      **
       * *    * *
       *  *  *  *
       *   **   *
       *   **   *
       *  *  *  *
       * *    * *
       **      **
       **********

       n = 8
       ********
       **    **
       * *  * *
       *  **  *
       *  **  *
       * *  * *
       **    **
       ********

       n = 6
       ******
       **  **
       * ** *
       * ** *
       **  **
       ******

07. n > 0 && n < 10
    n = 4
      4 4 4 4 4 4 4
      4 3 3 3 3 3 4
      4 3 2 2 2 3 4
      4 3 2 1 2 3 4
      4 3 2 2 2 3 4
      4 3 3 3 3 3 4
      4 4 4 4 4 4 4

08. n > 0 && n <= 26
    n = 5
      A B C D E D C B A
      A B C D   D C B A
      A B C       C B A
      A B           B A
      A               A

09. n > 0 && n < 10
    n = 5
          1
         212
        32123
       4321234
      543212345
       4321234
        32123
         212
          1

10. n > 0 && n < 10
    n = 7
      1 2 3 4 5 6 7
       2 3 4 5 6 7
        3 4 5 6 7
         4 5 6 7
          5 6 7
           6 7
            7
           6 7
          5 6 7
         4 5 6 7
        3 4 5 6 7
       2 3 4 5 6 7
      1 2 3 4 5 6 7

11. n >= 5 && n % 2 == 1
      n = 7
      *     * * * *
      *     *
      *     *
      * * * * * * *
            *     *
            *     *
      * * * *     *

      n = 5
      *   * * *
      *   *
      * * * * *
          *   *
      * * *   *
12. 
          **********
         *        *
        *        *
       *        *
      *        *
     **********

13. n >= 4 && n % 4 == 0
      n = 4
        *
       * *
      *   *
     * * * *

     n = 8
            *
           * *
          *   *
         * * * *
        *       *
       * *     * *
      *   *   *   *
     * * * * * * * *

    n = 12
                *
               * *
              *   *
             * * * *
            *       *
           * *     * *
          *   *   *   *
         * * * * * * * *
        *       *       *
       * *     * *     * *
      *   *   *   *   *   *
     * * * * * * * * * * * *

14. n > 0
    n = 7
     *
      **
       ***
        ****
         *****
          ******
           *******
          ******
         *****
        ****
       ***
      **
     *

15. n >=5 && n % 2 == 1
    n = 9
             *
           * * *
         * * * * *
       * * * * * * *
     * * * * * * * * *
       * * * * * * *
         * * * * *
           * * *
             *
           * * *
         * * * * *

16.
    * * * * * * * * * * * * * * * * *
      * * * * * * *   * * * * * * *
        * * * * *       * * * * *
          * * *           * * *
            * * * * * * * * *
              * * * * * * *
                * * * * *
                  * * *
                    *

